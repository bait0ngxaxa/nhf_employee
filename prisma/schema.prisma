generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}



model User {
  id              Int             @id @default(autoincrement())
  email           String          @unique
  name            String
  password        String
  role            String          @default("USER")
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  employeeId      Int?            @unique
  isActive        Boolean         @default(true)
  comments        TicketComment[]
  ticketViews     TicketView[]
  assignedTickets Ticket[]        @relation("AssignedTickets")
  reportedTickets Ticket[]        @relation("ReportedTickets")
  employee        Employee?       @relation(fields: [employeeId], references: [id])
  auditLogs       AuditLog[]
  emailRequests   EmailRequest[]

  @@map("users")
}

model Employee {
  id           Int            @id @default(autoincrement())
  firstName    String
  lastName     String
  phone        String?
  email        String         @unique
  position     String
  hireDate     DateTime       @default(now())
  status       EmployeeStatus @default(ACTIVE)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  departmentId Int
  affiliation  String?
  nickname     String?
  dept         Department     @relation(fields: [departmentId], references: [id])
  user         User?

  @@index([departmentId], map: "employees_departmentId_fkey")
  @@map("employees")
}

model Department {
  id          Int        @id @default(autoincrement())
  name        String     @unique
  code        String     @unique
  description String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  employees   Employee[]

  @@map("departments")
}

model Ticket {
  id           Int             @id @default(autoincrement())
  title        String
  description  String          @db.Text
  category     TicketCategory
  priority     TicketPriority  @default(MEDIUM)
  status       TicketStatus    @default(OPEN)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  resolvedAt   DateTime?
  reportedById Int
  assignedToId Int?
  comments     TicketComment[]
  views        TicketView[]
  assignedTo   User?           @relation("AssignedTickets", fields: [assignedToId], references: [id])
  reportedBy   User            @relation("ReportedTickets", fields: [reportedById], references: [id])

  @@index([assignedToId], map: "tickets_assignedToId_fkey")
  @@index([reportedById], map: "tickets_reportedById_fkey")
  @@map("tickets")
}

model TicketComment {
  id        Int      @id @default(autoincrement())
  content   String   @db.Text
  createdAt DateTime @default(now())
  ticketId  Int
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@index([authorId], map: "ticket_comments_authorId_fkey")
  @@index([ticketId], map: "ticket_comments_ticketId_fkey")
  @@map("ticket_comments")
}

model TicketView {
  id       Int      @id @default(autoincrement())
  viewedAt DateTime @default(now())
  ticketId Int
  userId   Int
  ticket   Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id])

  @@unique([ticketId, userId])
  @@index([userId], map: "ticket_views_userId_fkey")
  @@map("ticket_views")
}

enum EmployeeStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum TicketCategory {
  HARDWARE
  SOFTWARE
  NETWORK
  ACCOUNT
  EMAIL
  PRINTER
  OTHER
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  CANCELLED
}

// Audit Log for tracking critical actions per agent.md security standards
model AuditLog {
  id          Int         @id @default(autoincrement())
  action      AuditAction
  entityType  String      // e.g., "User", "Employee", "Ticket"
  entityId    Int?        // ID of the affected entity
  userId      Int?        // User who performed the action
  userEmail   String?     // Email for reference even if user deleted
  ipAddress   String?     // Client IP address
  userAgent   String?     @db.Text // Browser/client info
  details     String?     @db.Text // JSON string with additional details
  createdAt   DateTime    @default(now())
  user        User?       @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

enum AuditAction {
  // Authentication
  LOGIN_SUCCESS
  LOGIN_FAILED
  LOGOUT
  PASSWORD_CHANGE
  PASSWORD_RESET
  
  // Employee management
  EMPLOYEE_CREATE
  EMPLOYEE_UPDATE
  EMPLOYEE_DELETE
  EMPLOYEE_STATUS_CHANGE
  EMPLOYEE_IMPORT
  
  // Ticket management
  TICKET_CREATE
  TICKET_UPDATE
  TICKET_STATUS_CHANGE
  TICKET_ASSIGN
  TICKET_COMMENT
  
  // Admin actions
  USER_CREATE
  USER_UPDATE
  USER_DELETE
  USER_ROLE_CHANGE
  
  // System
  SETTINGS_UPDATE
  DATA_EXPORT
  EMAIL_REQUEST
}

// Email Request History for tracking new employee email requests
model EmailRequest {
  id           Int      @id @default(autoincrement())
  thaiName     String
  englishName  String
  phone        String
  nickname     String
  position     String
  department   String
  replyEmail   String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  requestedBy  Int
  user         User     @relation(fields: [requestedBy], references: [id])

  @@index([requestedBy])
  @@index([createdAt])
  @@map("email_requests")
}


